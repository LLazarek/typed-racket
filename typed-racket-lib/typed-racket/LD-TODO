- [X] rename #:locally-defensive to #:transient
- [X] add #:guarded
- [X] rename "#:tag" to "#:shape"
- [X] remove tag-reduce ... and do all the work inside type->contract instead?
      ... see what we need to add erasure ... maybe a type-contract unit works best?
- [X] interactions ....
  T = TR = Typed Racket = Natural embedding = type-sound = `\tau`
  S = transient = LD Racket = constructor sound = `\sigma`
  U = Racket = uni-typed
  - TR requires LD, add a contract
    ... or force require/typed
    ... or contract ONLY the diff between the annotated type and the runtime-inferred type
    ... try modifying 'current-typed-side' and 'typed-context?' to fix
    ... 2020-02-10 removed 'current-typed-side'
  - LD requires TR, need to protect the typed functions
    ... going to get tag-correct inputs, but need to protect outputs
  - LD not doing type-checks under a with-handlers ???
  - TR_N and TR_LD, order of require/typed matters ? (gee this is new)
  - LD possible to never use type->contract in defender, by generating all
    contracts up front?
- [X] 2020-02-17 fixed
  WTF: #<syntax:/home/ben/code/racket/gradual-typing-performance/benchmarks/tag_kcfa/benchmark/configuration1111111/main.rkt:27:25 args>
  compilation context...:
  /home/ben/code/racket/gradual-typing-performance/benchmarks/tag_kcfa/benchmark/configuration1111111/main.rkt
  context...:
  /home/ben/code/racket/shallow/tagged-racket/tagged-racket-lib/tagged-racket/defender/defender.rkt:591:0: protect-formals
  ...rivate/parse.rkt:535:26
  /home/ben/code/racket/6.10.1/collects/racket/private/map.rkt:20:13: map
  fail-handler33
  /home/ben/code/racket/shallow/tagged-racket/tagged-racket-lib/tagged-racket/tc-setup.rkt:33:4: for-loop
  /home/ben/code/racket/shallow/tagged-racket/tagged-racket-lib/tagged-racket/tc-setup.rkt:28:0: maybe-defend
  /home/ben/code/racket/shallow/tagged-racket/tagged-racket-lib/tagged-racket/tc-setup.rkt:105:0: tc-module/full
  /home/ben/code/racket/shallow/tagged-racket/tagged-racket-lib/tagged-racket/tagged-racket.rkt:23:4
  /home/ben/code/racket/6.10.1/collects/compiler/cm.rkt:363:0: compile-zo*
  /home/ben/code/racket/6.10.1/collects/compiler/cm.rkt:572:26
  /home/ben/code/racket/6.10.1/collects/compiler/cm.rkt:564:42
  /home/ben/code/racket/6.10.1/collects/compiler/cm.rkt:635:0: compile-root
  /home/ben/code/racket/6.10.1/collects/compiler/cm.rkt:737:4
  /home/ben/code/racket/6.10.1/share/pkgs/compiler-lib/compiler/commands/make.rkt:81:8: for-loop
  /home/ben/code/racket/6.10.1/share/pkgs/compiler-lib/compiler/commands/make.rkt: [running body]
  /home/ben/code/racket/6.10.1/collects/raco/raco.rkt: [running body]
- [X] ....
  ;; 2020-02-10 unclear whats problem, this compiles and runs, with or without for/or annotation
  ;#lang tagged/racket
  ;
  ;(struct component
  ;  ((id : Integer))
  ;  #:transparent)
  ;
  ;(struct frame
  ;  ((components : (Vectorof component)))
  ;  #:transparent)
  ;
  ;(: find-component (-> Integer frame (U #f component)))
  ;(define (find-component id frame)
  ;  (for/or #; (U #f component) ((c (in-vector (frame-components frame))))
  ;        (and (= (component-id c) id)
  ;             c)))
- [X] fsmoo/mbta/quadU/take5, object/sc and class/sc unsupported
- [X] synth, threadcell contract
- [X] acquire, cannot generate contract 2 cases of arity 1
- [X] acquire/dungeon/forth/zombie, sc->tag expected sc got void
- [X] sc->tag/c why return a static contract and not a contract? (issue with recursion?)
      yeah it's gotta be an sc because we're not ready to instantiate yet
- [X] fsm, expected (StructTypeTop ....) failed
- [X] plot build fails (see in-cycle.rkt test)
      opened issue in TR (), hacked-around for LD for now
      EDIT closed the TR issue, hack validated
- [X] make-typed-renaming needs 3 args but sometimes gets 2 ... how? (in-array.rkt)
- [X] fsm fsmoo --- need to check `type->flat-contract` returns #f
      application: not a procedure; expected a procedure that can be applied to arguments given: #f arguments...: 0
- [X] jpeg, can't use for/array because untype-contract restricts Transient
      uses, but not typed ones
- [X] quadU errors in untyped and typed, by cadr
      error changed after revert x4:
        sc->tag/c: not implemented for (cons/sc (flat/sc symbol?) (cons/sc (listof/sc (cons/sc (flat/sc symbol?) #0=any/sc)) (listof/sc #0#)))
      error not fixed by removing rts provides
      fixed again by not defining predicates in LD code
- [X] fsmoo (population) quadU (utils) quadT (core-types) forth (command) slow to compile
      even typed maybe
      - fsmoo seems much better 2020-02-14 ... forth BAD
      - 2020-02-17 : forth and quadU were looping in contract generation,
        because of name/sc lookups (recursively converting everything in
        name-table to tags?)
        quadT also needed to move the `quad` macro to a new file, so LD code
         doesn't need to use a typed macro
- [X] simplify tag-reduce for no fuel? (does that help much?)
      2020-02-18 ok now, no depth argument, all decided by LD parameter
- [X] fixup name-table code? make a tag-table on the side?
      yeah if we make tags from the start, no need! the table contains tags and doesn't need to be cut later
- [X] can we have type->contract unit & avoid building full sc's ahead of time?
      lets try 3 functions for the first
      ... at least T vs S and we will see if there are code savings
      LOOKS GOOD
- [X] remove sc->tag
- [X] check diff, anything else to remove?
- [X] remove contract-first-order for classes .... when?
      maybe should wait, until we can measure the difference of building or not ... no thats silly just make it easy to go back
      HALF-way removed, it's there but lifted to toplevel; could not check
       field + method membership otherwise (need to use class internals)
- [X] jpeg, jfif.rkt component? use-before-def error
      dammit, struct contract
      cannot do contract = foo?
      need contract = (lambda (x) (foo? x))
      because foo? might not be defined yet, and these are lifted to the toplevel
- [X] lnm missing type for plot-pict
      its a define-typed/untyped-id ... need require/typed on the client side
- [X] runtime perf: sieve
- [X] 'typed-world ? it's a blame label for `cast` ... we could rename depending
      on the mode for the current types, but I don't think it matters
- [X] remove `typed ? at least clearly distinguish a mode from a side
- [X] remove current-typed-side ?
- [X] what goes wrong in type->contract doesn't set parameter?
      nothing yet, so change to an assert for now
- [X] bless string->path
- [X] can transient macro appear in untyped?
  well the macro code CANNOT be type checked and IS NOT defended
  ... unclear what defense to add to (f x) --> (car (car x))
  ... if unoptimized then could be fine right?
  ... yeah I think this is fine, ESCAPE is a problem,
      but not really right now because all functions are defended no worries about escape
  OK allowed now
- [X] bless check-list
  ... and anything that returns void? NO contexts can distinguish void (void? X) (if X ....)
- [X] ??? variable-reference-constant? #%variable-reference --- probably TR internal
      yeah looks like TR internals
- [X] register-type, look over
- [X] ... anything returns Nothing (none/c/proc) ... well doesn't change error, but generates a lot of code
- [X] ??? make-sequence
         (let-values (((pos->vals pos-pre-inc pos-next init pos-cont?  val-cont?  all-cont?)
                       (let-values (((dyn-cod22 dyn-cod23 dyn-cod24 dyn-cod25 dyn-cod26 dyn-cod27 dyn-cod28)
                                     (#%app make-sequence '(word+freq) words+freqs)))
                         (if (if (#%plain-app g11 dyn-cod22) (if (#%plain-app g14 dyn-cod23) (if (#%plain-app g11 dyn-cod24) (if (#%plain-app g14 dyn-cod26) (if (#%plain-app g14 dyn-cod27) (#%plain-app g21 dyn-cod28)
                                       '#f) '#f) '#f) '#f) '#f)
                           (#%app values dyn-cod22 dyn-cod23 dyn-cod24 dyn-cod25 dyn-cod26 dyn-cod27 dyn-cod28)
                           (#%plain-app error 'dynamic-typecheck '"'(#%app make-sequ... : ((-> Any (List String Integer)) (U (-> Any Any) False) (-> Any Any) Any (U (-> Any Any) False) (U (-> (List String Integer) Any) False) (U (-> Any (List String Integer) Any) False))")))))
  2020-03-03 pretty sure fixed by changing the base environment
- [X] for-loop lambda ... all these ifs might be killing loops idk
  2020-03-03 saves ~1/2 second in morsecode
  fixed with pattern-match + optimizer escape analysis
- [X] fill = lambda ... escape analysis?
      ditto for loops (again they can escape)
- [X] rackunit env broke
  fixed rackunit by reverting make-env
- [X] does extra-env lang need changes for transient?
  plot is the only user, seems fine
- [X] define-predicate really flat?
  2020-03-03 yes, makes a shallow contract
- [X] suffixtree 4s typed 40s tagged???
      that's not too far off from ICFP after all ... 10s slower
      2020-03-03 down to 30s
- [X] TR master, need pattern-match to create list/sc
  2020-03-03 looks like its never created, gee!
  if we had this on master, LD can use to check list? and
   later use list? knowledge for cdr
   (important for for-loops list sequence iteration)
  2020-03-03 done see PR #911
- [X] can vec? check be simpler, instead of union ivec mvec?
      ditto for hash ... this is not a pretty solution though
- [X] cdr does not need check if applied to a Listof type
  2020-03-03 List -> cons?, so its not safe ... hard to tell Cons vs List in
   type->contract
- [X] morsecode/sieve/snake/tetris, very slow runtime (require-typed-check bug?)
      ... better now after checking "blessed" but heres now fully-typed vs ICPF worst-case
      morsecode : 4.45 vs 3.48 ... 2020-03-04 : ~2x
      sieve : 2.84 vs 1.69     ... 2020-03-04 : ~2x
      snake : 11.3 vs 6.7      ... 2020-03-04 : ~4x
      tetris : 1.2 vs 8.8      ... 2020-03-04 : ~3x
      zombie : 24x vs 20x      ... 2020-03-04 : ~14x
      ICFP should always be slower, but its not ... WTF snake & tetris!!!!!
- [X] class error
  - [X] fix acquire dungeon take5 quadU quadT ... all these were typo in class-checker generation code who would have thought
- [X] fix zordoz bad memory segfault
  - [X] fails fully-typed on my fork
  - [X] succeeds fully-typed on 7.6 BC release
  - [X] fails untyped too, OK THEN!
  - [X] reduce untyped? yep reduced to contract-out
  - [X] mflatt fixed the bug yesterday!
- [X] typed-racket-test/transient/error/values.rkt, typed-racket-test/transient/pass/ll-lambda.rkt
      typed-racket-lib/typed-racket/defender/defender.rkt:516.24:
       and: expected one of these identifiers: `#%plain-app', `begin', `begin0', `#%plain-app', `#%plain-lambda', `if', `with-continuation-mark', `#%top', `#%variable-reference', `quote', `quote-syntax', `case-lambda', `let-values', `letrec-values', `#%expression', or `set!'
- [X] typed-racket-test/transient/pass/for-array.rkt
      typed-racket-test/transient/pass/in-array.rkt
      typed-racket-test/transient/pass/match-define.rkt
      typed-racket-test/transient/pass/poly-union.rkt
      typed-racket-test/transient/pass/tc-app-special.rkt
      <pkgs>/math-lib/math/private/array/array-sequence.rkt:31.26: unless: expected one of these identifiers: `#%plain-app', `begin', `begin0', `#%plain-app', `#%plain-lambda', `if', `with-continuation-mark', `#%top', `#%variable-reference', `quote', `quote-syntax', `case-lambda', `let-values', `letrec-values', `#%expression', or `set!'
        at: unless
        in: (unless (#%plain-app g4 arr) (#%plain-app error (quote transient-assert) (#%plain-app format (quote "got ~s in ~a") arr (quote "'arr : (Array g4514144)"))))
- [X] factorial, if issue
      all if statements turning into dead code,
      because type checker adds marks for every branch taken --- and these got lost,
       need to copy them over
- [X] typed-racket-test/transient/pass/alias.rkt
      typed-racket-test/transient/pass/lambda.rkt
      typed-racket-test/transient/pass/list-ref.rkt
      typed-racket-test/transient/pass/submodule-transient.rkt
      syntax/loc: contract violation
        expected: syntax?
        given: '(#<syntax:/Users/ben/code/racket/fork/extra-pkgs/typed-racket/typed-racket-test/transient/pass/alias.rkt:8:1 +> #<syntax (quote 2)> #<syntax (quote 2)>)
- [X] acquire dungeon forth fsm errors ....
      got 'values' expected kernel-literal
- [X] optimizer
  leave S,E macros un-optimized (should be no problem ... but lets see)
  yes they are skipped optimizer/optimizer L67
  - [X] disable pair, if for transient
  - [X] try running benchmarks
- [X] tc-app-lambda todo items (PR to TR?)
  - [X] ((lambda ....) ....) seems more-correct now, but's also apparently unnecessary,
    worth doing a TR PR though
    NO not unneccessary this transient code fails, missing type
     ((lambda (x) (values x (list 'A 'A))) 42)
    [X] submit PR 1, ...
  - [X] ((letrec-values ....) ....) seems fine without annotation,
    but double-check benchmarks?


- [ ] investigate contract generation, where do names go what gets reused?
  - objects are looking fine
- [ ] unhygienic S require T identifier
      use contract-def/provide-property ?

- [ ] transient breaks tail calls? or does typed-id? check make it okay?
  - Herman or Disney might have a (workshop?) paper about this,
    moving contracts into continuation marks

- [ ] low priority: change extra-env-lang to accept transient blessing,
      plot-lib is the only user I know of
- [ ] bless require/typed struct predicates

- [ ] cod check for/list etc, its always a list or void or sum
  (2020-02-28 still a problem, (check (#%app for-loop  ....)))

- [ ] pos->vals appears in for loop expansion, gets a cod check, but doesn't need one why
  "pos->vals" is only a variable name, used to describe the first result of `make-sequence`, great
  one fix: give `make-sequence` a deeper type and in the defender check for "deeper"
   ... so pos->vals gets a blessed type
   ... and this means, I guess, that transient-env is the wrong choice; instead
    should key on types rather than identifiers

- [ ] for way later ... mutable things get a proxy, tracks "correct" indexes
  who knows if that will pay off

- [ ] 2020-03-14 review diff again, factor thhings into PRs

- [ ] dungeon, cell.rkt, why 3 copies of same recursive-contract ?


